덧칠하기
=
## 🕵️문제설명
어느 학교에 페인트가 칠해진 길이가 `n`미터인 벽이 있습니다. 벽에 동아리 · 학회 홍보나 회사 채용 공고 포스터 등을 게시하기 위해 테이프로 붙였다가 철거할 때 떼는 일이 많고 그 과정에서 페인트가 벗겨지곤 합니다. 페인트가 벗겨진 벽이 보기 흉해져 학교는 벽에 페인트를 덧칠하기로 했습니다.

넓은 벽 전체에 페인트를 새로 칠하는 대신, 구역을 나누어 일부만 페인트를 새로 칠 함으로써 예산을 아끼려 합니다. 이를 위해 벽을 1미터 길이의 구역 `n`개로 나누고, 각 구역에 왼쪽부터 순서대로 1번부터 `n`번까지 번호를 붙였습니다. 그리고 페인트를 다시 칠해야 할 구역들을 정했습니다.

벽에 페인트를 칠하는 롤러의 길이는 `m`미터이고, 롤러로 벽에 페인트를 한 번 칠하는 규칙은 다음과 같습니다.

- 롤러가 벽에서 벗어나면 안 됩니다.
- 구역의 일부분만 포함되도록 칠하면 안 됩니다.

즉, 롤러의 좌우측 끝을 구역의 경계선 혹은 벽의 좌우측 끝부분에 맞춘 후 롤러를 위아래로 움직이면서 벽을 칠합니다. 현재 페인트를 칠하는 구역들을 완전히 칠한 후 벽에서 롤러를 떼며, 이를 벽을 한 번 칠했다고 정의합니다.

한 구역에 페인트를 여러 번 칠해도 되고 다시 칠해야 할 구역이 아닌 곳에 페인트를 칠해도 되지만 다시 칠하기로 정한 구역은 적어도 한 번 페인트칠을 해야 합니다. 예산을 아끼기 위해 다시 칠할 구역을 정했듯 마찬가지로 롤러로 페인트칠을 하는 횟수를 최소화하려고 합니다.

정수 n, m과 다시 페인트를 칠하기로 정한 구역들의 번호가 담긴 정수 배열 section이 매개변수로 주어질 때 롤러로 페인트칠해야 하는 최소 횟수를 return 하는 solution 함수를 작성해 주세요.

## ⚠️제한사항

3 ≤ number의 길이 ≤ 13
-1,000 ≤ number의 각 원소 ≤ 1,000
서로 다른 학생의 정수 번호가 같을 수 있습니다.

## 입출력 예

입출력 예 #1

- 예제 1번은 2, 3, 6번 영역에 페인트를 다시 칠해야 합니다. 롤러의 길이가 4미터이므로 한 번의 페인트칠에 연속된 4개의 구역을 칠할 수 있습니다. 처음에 3, 4, 5, 6번 영역에 페인트칠을 하면 칠해야 할 곳으로 2번 구역만 남고 1, 2, 3, 4번 구역에 페인트칠을 하면 2번 만에 다시 칠해야 할 곳에 모두 페인트칠을 할 수 있습니다.

![](https://velog.velcdn.com/images/guysang/post/8101db0d-114b-4167-8771-a6e5225e02cb/image.png)

2번보다 적은 횟수로 2, 3, 6번 영역에 페인트를 덧칠하는 방법은 없습니다. 따라서 최소 횟수인 2를 return 합니다
## 🔎로직설명
### 1차 코드
```kotlin
fun solution(n: Int, m: Int, section: IntArray): Int {
        var answer = 0
        var end = 0
        for (i in section){
            if (i > end){
                end = i + m - 1
                answer++
            }
        }
        return answer
    }
```
벽의 배열에서 section[0]부터 시작해서 롤러의 크기만큼 지나간다음 칠하는 범위의 끝을 나타낼 변수 end를 만들어준다

반복문을 실행 하는데 가상의 벽을 나타내는 배열 val wall이 있다 해보자

wall.size는 n이고 우리는 여기서 section[n]:Int가 나타내는 원소를 칠해야한다

그 말은 즉슨 wall[section[n]]을 시작점으로 잡고 wall[section[end]]까지 칠하는 범위가 몇번 인지 구하는것이다

> ? 그러면 롤러의 크기가 4이고 [1,2,3,4,5,6]인 벽을 칠해야 할때 어떡함?
[1,2,3,4]칠하고 [3,4,5,6] 칠해야하는거 아님??
>>아니다 범위는 1234 3456을 칠하든 1234 56xx 벽을 넘어 롤러절반을 허공에 띄운채로 칠하든 결국 칠해야하는 횟수는 같다 wall의 size를 기준으로 반복문을 하는게 아닌
벽의 위치를 나타내는 배열을 반복하는거라 에러가 뜰일도 없다

section의 모든 요소를 보고 end보다 작으면 무시하고 크면 answer를 늘리면서 end값을 i + 롤러크기 -1 해주면 된다

### 2차 수정
```kotlin
fun solution(n: Int, m: Int, section: IntArray): Int {
    var count = 0
    var end = 0
    section.forEach { if (it > end) { end = it + m - 1; count++ } }
    return count
}
```
코드 흐름을 이해했으니 더 간결하게 만들어 보았다

for문을 -> section.forEach로 바꿔 각 요소들을 end와 비교 하고 수식을 넣어 간결하게 만들었다

### 3차 수정

```kotlin
fun solution(n: Int, m: Int, section: IntArray) = section.fold(0 to 0) {
 (count, end), s -> if (s > end) count + 1 to s + m - 1 else count to end }.first
```
더 간단하게 코드를 만들 순 없을까? 했지만

놀랍게도 가능하다

fold를 사용해서 위에서 정의한 변수 count와 end를 pair로 0으로 한번에 설정하고 컬렉션의 요소 s를 비교

요소가 end보다 크면 카운트를 1 늘리고 to (end)는 요소+m-1 해준다

else는 count end 그대로

fold가 끝나면 .first를 써 count to end 중 처음에 있던 count를 반환한다